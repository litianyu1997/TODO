<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>图结构</title>
</head>
<body>
    <script src="dict.js"></script>
<script>
    // 封装图结构
    function Graph(){
        // 属性：顶点(数组)/边(字典)
        this.vertexes = []; // 顶点
        this.edges = new Dictionary(); // 边

        // 方法
        // 添加方法
        // 添加顶点的方法
        Graph.prototype.addVertex = function(v){
            this.vertextes.push(v);
            this.edges.set(v,[]);
        }

        // 添加边值的方法
        Graph.prototype.addEdge = function(v1,v2){
            this.edges.get(v1).push(v2);
            this.edges.get(v1).push(v1);
        }

        // 实现toString方法
        Graph.prototype.toString = function(){
            // 定义字符串，保存最终的结果
            var resultString = "";

            // 遍历所有的顶点，以及顶点对应的边
            for(var i = 0; i < this.vertexes.length; i++){
                resultString += this.vertexes[i] + '->';
                var vEdges = this.edges.get(this.vertexes[i]);
                for(var j = 0; j < vEdges.length; j++){
                    resultString += vEdges[j] + ' ';
                }
                resultString += '\n';
            }
            return resultString;
        }

        // 初始化颜色
        Graph.prototype.initializeColor = function(){
            var colors = [];
            for(var i = 0; i < this.vertexes.length; i++){
                colors[this.vertexes[i]] = 'white';
            }
            return colors;
        }

        // 实现广度优先搜索(BFS)
        Graph.prototype.bfs = function(initV,handler){
            // 初始化颜色
            var colors = this.initializeColor();

            // 创建队列
            var queue = new Queue();

            // 将顶点加入队列中
            queue.enqueue(initV);

            // 循环从队列中取出元素
            while(!queue.isEmpty()){
                // 从队列中取出一个顶点
                var v = queue.dequeue();

                // 获取和顶点相连的另外顶点
                var vList = this.edges.get(v);

                // 将v的颜色设置成灰色
                color[v] = 'gray';

                // 遍历所有的顶点，并且加入到队列中
                for(var i = 0; i < vList.length; i++){
                    var e = vList[i];
                    if(colors[e] == 'white'){
                        colors[e] == 'gray';
                        queue.enqueue(e);
                    }
                }

                // 访问顶点V
                handler(v);

                // 将顶点设置为黑色
                colors[v] = 'black';
            }
        }

        // 深度优先搜索(DFS)
        Graph.prototype.dfs = function(initV, handler){
            // 初始化颜色
            var colors = this.initializeColor();

            // 从某个顶点开始依次递归访问
        }

        Graph.prototype.dfsVisit = function(v, colors, heandler){
            // 将颜色设置为灰色
            colors[v] = gray;

            // 处理v顶点
            handler(v);

            // 访问v相连的顶点
            var vList = this.edges.get(v);
            for(var i = 0; i < vList; i++){
                var e = vList[i];
                if(colors[e] == 'white'){
                    this.dfsVisit(e, colors, handler);
                }
            }

            // 将v设置成黑色
            colors[v] = 'black';
        }
    }

    // 测试代码
    // 创建图结构
    var g = new Graph();

    // 添加顶点
    var myVertexes = ['A','B','C','D','E','F','G','H','I',];
    for(var i = 0; i < myVertexes.length; i++){
        g.addVertex(myVertexes[i]);
    }

    // 添加边
    graph.addEdge('A','B');
    graph.addEdge('A','C');
    graph.addEdge('A','D');
    graph.addEdge('C','D');
    graph.addEdge('C','G');
    graph.addEdge('D','G');
    graph.addEdge('D','H');
    graph.addEdge('B','E');
    graph.addEdge('B','F');
    graph.addEdge('E','I');

    // 测试bfs
    graph.bfs(graph.vertexes[0],function(v){
        result += v + ' ';
    })
    alert(result); // ABCDEFGHI

    // 测试dfs
    result = '';
    graph.dfs(graph.vertexes[0],function(v){
        result += v + ' ';
    })









</script>
</body>
</html>