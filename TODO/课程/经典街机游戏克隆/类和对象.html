<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 回调
        function callAndAdd(n, callbackFunction){
            return n + callbackFunction();
        }

        // 数组的forEach()方法接受一个回调函数，并为数组中的每个元素调用该函数
        array.forEach(function callback(currentValue, index, array){
            // 函数代码
        });

        // 打印奇数
        function logIfOdd(n){
            if(n % 2 !== 0){
                console.log(n);
            }
        };

        // 打印数组内奇数
        [1, 4, 2, 4, 6, 3].forEach(function logIfOdd(n){
            if(n % 2 !== 0){
                console.log(n);
            }
        });

        function returnsThree(){
            return 3;
        }

        // 数组的map()方法类似于forEach()，也会为数组中的每个元素调用一个回调函数。但是，.map()会根据回调函数所返回的内容返回一个新的数组
        const names = ['David', 'Richard', 'Veronika'];

        const nameLengths = name.map(function(name){
            return name.length;
        });
        // 在names数组上调用map()，并将一个匿名函数作为参数传递给它
        names.map(function(name){
            return name.length;
        });

        // filter()
        names.filter(function(name){
            return name.length < 6;
        });

        // 闭包
        function remember(number){
            return function(){
                return number;
            }
        }

        const returnedFunction = remember(5);

        console.log( returnedFunction());

        // 闭包和作用域
        const myName = 'Andrew';

        function introduceMyself(){
            const you = 'student';

            function introduce(){
                console.log(`Hello , ${you}, I'm ${myName}!`);
            }

            return introduce();
        }

        introduceMyself();

        // 函数声明与函数表达式  立即调用函数表达式(IIFE)
        function returnHello(){
            return 'Hello!';
        }

        // 匿名
        const myFunction = function(){
            return 'Hello!';
        }

        // 命名
        const otherFunction = function returnHello(){
            return 'Hello!';
        }

        // 立即调用
        (function sayHi(){
            alert('Hi there!');
        })();

        // 向IIFE传递参数
        (function (name){
            alert('Hi, ' + name);
        })('Andrew');

        (function (x, y){
            console.log(x * y);
        })(2, 3);

        // IIFE和私有作用域
        const myFunction = (
            function (){
                const hi = 'Hi!';
                return function(){
                    console.log(hi);
                }
            }
        )();

        // IIFE的替代语法
        (function sayHi(){
            alert('Hi there!');
        })();

        // 构造函数：结构和语法
        function SoftwareDeeveloper(){
            this.favoriteLanguage = 'JavaScript';
        }

        // 创建多个对象
        let engineer = new SoftwareDeveoper();
        let programmer = new SoftwareDeveloper();
        console.log(engineer);
        console.log(programmer);

        // 构造函数可以有参数
        function SoftwareDeveloper(name){
            this.favoriteLanguage = 'JavaScript';
            this.name = name;
        }

        let instructor = new SoftwareDeveloper('Andrew');

        console.log(instrucetor);

        let teacher = new SoftwareDeveloper('Richard');

        console.log(teacher);

        // 构造函数中的this
        function Cat(name){
            this.name = name;
            this.lives = 9;
            this.sayName = function(){
                console.log( 'Meow! My name is '+this.name);
            };
        }

        const bailey = new Cat();

        // {
        //     name: Bailey,
        //     sayName: function (){
        //         console.log('Meow! My name is ' + this.name);
        //     }
        // }

        bailey.sayName();

        // this什么时候会被赋值
        const dog = {
            bark: function(){
                console.log('Woof!');
            },
            barkTwice: function(){
                this.bark();
                this.bark();
            }
        };

        // -------------
        function Hero(name,role){
            this.name = name;
            this.role = role;

            this.introduce = function(){
                console.log(`My name is ${this.name} and I am a ${this.role}.`);
            }
        }

        const taylor = new Hero('Taylor','mother');
        const riley = new Hero('Riley','coach');

        taylor.introduce();
        riley.introduce();
        // -------------

        // 设定this的值
        //call() apply() bind()

        // 秘密链接
        const bear = {
            claws: true,
            diet: 'carnivore'
        };

        function PolarBear() {
            // ...
        };
        PolarBear.prototype = bear;

        const snowball = new PolarBear();
        snowball.color = 'white';
        snowball.favoriteDrink = 'cola';

        console.log(snowball.claws);
        console.log(snowball.diet);
        // 由于claw和diet都作为prototype对象中的属性存在，因此他们会被查找，因此对象被秘密链接到其构造函数的prototype属性

        // Object.create(proto[,propertiesObject])
        // 参数：
        // proto新创建对象的原型对象
        // propertiesObject 可选，如果没有指定为undefined，则是要添加到新创建对象的可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)对象的属性描述符以及相应的属性名称。这些属性对应Object.definedProperties()的第二个参数
        // 返回值：一个新对象，带着指定的原型对象和属性


    </script>
</body>
</html>