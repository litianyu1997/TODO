<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 习题1
        function getClothing(isCold){
            if(isCold){
                var freezing = "Grab a jacket!";
            }else{
                var hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：undefined
        // 提升：提升是浏览器解析JavaScript的结果。本质上，在执行任何JavaScript代码之前，所有的变量都会被"提升"，也就是提升到函数作用域的顶部。因此在运行时，getClothing()函数实际上看起来如下
        function getClothing(isCold){
            var freezing, hot;
            if(isCold){
                freezing = "Grab a jacket!";
            }else{
                hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // let和const
        // 使用let和const声明的变量解决了这种提升问题，因为它们的作用域是到块，而不是函数。
        // 如果在代码块中使用let或const声明变量，那么该变量会陷入暂时性死区，直到该变量的声明被处理。这种行为会阻止变量被访问，除非它们被声明了。
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // 使用let和const声明的变量仅在它们所声明的块中可用

        // 习题2
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：ReferenceError:freezing is not defined
        // 使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明
        // 使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值

        // 习题3
        let instructor = 'James';
        instructor = 'Richard';
        console.log(instructor);
        // Q:运行以上代码后的输出是什么
        // A:Richard

        // 模板字面量
        // 源代码
        var note = teacher.name + ',\n\n' +
        'Please excuse ' + student.name + '.\n' +
        'He is recovering from the flu.\n\n' +
        'Thank you,\n' +
        student.guardian;
        // 更改
        var note = `${teacher.name},
        Please excuse ${student.name}.
        He is recovering from the flu.
        Thankyou,
        ${student.guardian}`;

        // 解构数组中的值
        const point = [10, 25, 34];

        const [x, y, z] = point;

        console.log(x, y, z);
        // Prints:10 25 -34
        
        // 习题1
        let positions = ['Gabrielle', 'Jarrod', 'Kate', 'Fernando', 'Mike', 'Walter'];
        let [first, second, third] = positions;
        // Q:运行以上代码后，second的值为多少
        // A:Jarrod

        // 习题2
        const circle = {
            radius: 10,
            color: 'orange',
            getArea: function(){
                return Math.PI * this.radius * this.radius;
            },
            getCircumference: function(){
                return 2*Math.PI * this.radius;
            }
        };
        let {radius, getArea, getCircumference} = circle;
        // Q:调用getArea()后会返回什么
        // A:NaN
        // 在解构该对象并将getArea()方法存储到getArea变量中时，它无法再访问circle对象中的this

        // 字面量简写法
        let type = 'quartz';
        let color = 'rose';
        let carat = 21.29;

        const gemstone = {
            type: type,
            color: color,
            carat: carat,
            calculateWorth: function(){

            }
        };
        // 简写
        getmstone = { type, color, carat,calculateWorth(){ } };


        // 迭代
        // for循环
        const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        for(let i = 0; i < digits.length; i++){
            console.log(digits[i]);
        }

        // for...in循环
        for(const index in digits){
            console.log(digits[index]);
        }

        // for...of循环
        for(const digit of digits){
            console.log(digit);
        }
        // for...of循环解决了for和for...in循环的不足之处，可以随时停止或退出for...of循环
        for(const digit of digits){
            if(digit % 2 === 0){
                continue;
            }
            console.log(digit);
        }


        // 展开运算符(用三个连续的点表示)是ES6中的新概念，能够将字面量对象展开为多个元素
        const primes = new Set[2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
        console.log(...primes);

        // 使用concat方法结合数组
        const fruits = ["apples", "bananas", "pears"];
        const vegetables = ["corn", "potatoes", "carrots"];
        const produce = fruits.concat(vegetables);
        console.log(produce);
        // Prints: ["apples", "bananas", "pears", "corn", "potatoes", "carrots"]

        const produce = [fruits, vegetables];
        console.log(produce);
        // Prints: [Array[3], Array[3]]

        // 剩余参数也用三个连续的点表示，能够将不定数量的元素表示为数组
        // 将变量赋数组值时
        const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
        const [total, subtotal, tax, ...items] = order;
        console.log(total, subtotal, tax, items);
        // Prints: 20.17 18.67 1.5 ["cheese", "eggs", "milk", "bread"]
        // 通过使用剩余参数，数组中剩余的值(作为数组)被分配给了items

        // 可变参数函数
        function sum(...nums){
            let total = 0;
            for(const num of nums){
                total += num;
            }
            return total;
        }


        // 箭头函数
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(function(name){
            return name.toUpperCase();
        });

        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
            name => name.toUpperCase()
        );

        // 将函数转换为箭头函数
        // 1、删掉关键字function
        // 2、删掉圆括号
        // 3、删掉左右花括号
        // 4、删掉关键字return
        // 5、删掉分毫
        // 在参数列表和函数主体之间添加一个箭头(=>)

        // 习题1
        setTimerout(() => {
            console.log('starting the test');
            test.start();
        },2000);

        setTimerout(_ => {
            console.log('starting the test');
            test.start();
        },2000);

        const vowels = 'aeiou'.split('');
        const bigVowels = vowels.map((letter) => letter.toUpperCase());

        const vowels = 'aeiou'.split('');
        const bigVowels = vowels.map(letter => letter.toUpperCase());
        // Q:以上哪些项的箭头函数格式正确
        // A:都正确

        // 简写主题语法 (在函数主体周围没有花括号，自动返回表达式)
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
            name => name.toUpperCase
        );

        // 常规主体语法 (它将函数主体放在花括号内，需要使用return语句来返回内容)
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map( name => {
            name = name.toUpperCase();
            return `${name} has ${name.length} characters in their name`;
        });

        // 习题2
        // 题目
        const colors = ['red', 'blue', 'green', 'yellow', 'orange', 'black'];
        
        // 选项1
        const crazyColors = colors.map(color => {
            const jumble = color.split('').reverse();
            return jumble.join('') + "!";
        });
        // 选项2
        const crazyColors = colors.map(color => {
            color.split('').reverse().join('') + "!";
        });
        // 选项3
        const crazyColors = colors.map(color => return color.split('').reverse().join('') + "!");
        // 选项4
        const crazyColors = colors.map(color => color.split('').reverse().join('') + "!");
        // Q:以上哪些时正确的箭头函数格式
        // A:1,4


        // "this"和箭头函数
        // 构造函数
        function IceCream(){
            this.scoops = 0;
        }
        // 为IceCream添加addScoop方法
        IceCream.prototype.addScoop = function(){
            setTimeout(() => {
                this.scoops++;
                console.log('scoop added!');
            },500);
        };
        const dessert = new IceCream();
        dessert.addScoop();

        // 默认函数参数
        function greet(name = 'Student', greeting = 'Welcome'){
            return `${greeting} ${name}!`;
        }

        // 习题1
        function houseDescriptor([houseColor = 'green', shutterColors = [red]]){
            return `I have a ${houseColor} house with ${shutterColors.join(' and ')} shutters`;
        }
        // 选项1
        houseDescriptor('red',['white', 'gray', 'pink']);
        // 选项2
        houseDescriptor(['green',['white', 'gray', 'pink']]);
        // 选项3
        houseDescriptor(['blue','purple']);
        // 选项4
        houseDescriptor(['green']);
        // Q:以上哪些选项可以正常运行
        // A:2,4

        // 默认值和解构对象
        function createSundae({scoops = 1, toppings = ['Hot Fudge']} = {}){
            const scoopText = scoops === 1 ? 'scoop' : 'scoops';
            return `Your sundae has ${scoops} ${scoopText} with ${toppings.join(' and ')} toppings.`;
        }
        createSundae({});
        createSundae({scoops:2});
        createSundae({scoops:2, toppings: ['Sprinkles']});
        createSundae({toppings: ['Cookie Dough']});
        // Returns:
        // Your sundae has 1 scoop with Hot Fudge toppings.
        // Your sundae has 2 scoops with Hot Fudge toppings.
        // Your sundae has 2 scoops with Sprinkles toppings.
        // Your sundae has 1 scoop Cookie Dough toppings.

        // 习题2
        function houseDescriptor({houseColor = 'green', shutterColors = ['red']} = {}){
            return `I have a ${houseColor} house with ${shutterColors.join(' and ')} shutters`;
        }
        // 选项1
        houseDescriptor({houseColor:'red',shutterColors:['white','gray','pink']});
        // 选项2
        houseDescriptor({houseColor:'red'});
        // 选项3
        houseDescriptor();
        // 选项4
        houseDescriptor({shutterColors:['orange','blue']});
        // 选项5
        houseDescriptor({});
        // Q:上面的哪些选项可以正常运行
        // A:全都可以
        

    </script>
</body>
</html>