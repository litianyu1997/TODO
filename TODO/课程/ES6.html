<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 习题1
        function getClothing(isCold){
            if(isCold){
                var freezing = "Grab a jacket!";
            }else{
                var hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：undefined
        // 提升：提升是浏览器解析JavaScript的结果。本质上，在执行任何JavaScript代码之前，所有的变量都会被"提升"，也就是提升到函数作用域的顶部。因此在运行时，getClothing()函数实际上看起来如下
        function getClothing(isCold){
            var freezing, hot;
            if(isCold){
                freezing = "Grab a jacket!";
            }else{
                hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // let和const
        // 使用let和const声明的变量解决了这种提升问题，因为它们的作用域是到块，而不是函数。
        // 如果在代码块中使用let或const声明变量，那么该变量会陷入暂时性死区，直到该变量的声明被处理。这种行为会阻止变量被访问，除非它们被声明了。
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // 使用let和const声明的变量仅在它们所声明的块中可用

        // 习题2
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：ReferenceError:freezing is not defined
        // 使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明
        // 使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值

        // 习题3
        let instructor = 'James';
        instructor = 'Richard';
        console.log(instructor);
        // Q:运行以上代码后的输出是什么
        // A:Richard

        // 模板字面量
        // 源代码
        var note = teacher.name + ',\n\n' +
        'Please excuse ' + student.name + '.\n' +
        'He is recovering from the flu.\n\n' +
        'Thank you,\n' +
        student.guardian;
        // 更改
        var note = `${teacher.name},
        Please excuse ${student.name}.
        He is recovering from the flu.
        Thankyou,
        ${student.guardian}`;

        // 解构数组中的值
        const point = [10, 25, 34];

        const [x, y, z] = point;

        console.log(x, y, z);
        // Prints:10 25 -34
        
        // 习题1
        let positions = ['Gabrielle', 'Jarrod', 'Kate', 'Fernando', 'Mike', 'Walter'];
        let [first, second, third] = positions;
        // Q:运行以上代码后，second的值为多少
        // A:Jarrod

        // 习题2
        const circle = {
            radius: 10,
            color: 'orange',
            getArea: function(){
                return Math.PI * this.radius * this.radius;
            },
            getCircumference: function(){
                return 2*Math.PI * this.radius;
            }
        };
        let {radius, getArea, getCircumference} = circle;
        // Q:调用getArea()后会返回什么
        // A:NaN
        // 在解构该对象并将getArea()方法存储到getArea变量中时，它无法再访问circle对象中的this

        // 字面量简写法
        let type = 'quartz';
        let color = 'rose';
        let carat = 21.29;

        const gemstone = {
            type: type,
            color: color,
            carat: carat,
            calculateWorth: function(){

            }
        };
        // 简写
        getmstone = { type, color, carat,calculateWorth(){ } };


        // 迭代
        // for循环
        const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        for(let i = 0; i < digits.length; i++){
            console.log(digits[i]);
        }

        // for...in循环
        for(const index in digits){
            console.log(digits[index]);
        }

        // for...of循环
        for(const digit of digits){
            console.log(digit);
        }
        // for...of循环解决了for和for...in循环的不足之处，可以随时停止或退出for...of循环
        for(const digit of digits){
            if(digit % 2 === 0){
                continue;
            }
            console.log(digit);
        }


        // 展开运算符(用三个连续的点表示)是ES6中的新概念，能够将字面量对象展开为多个元素
        const primes = new Set[2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
        console.log(...primes);

        // 使用concat方法结合数组
        const fruits = ["apples", "bananas", "pears"];
        const vegetables = ["corn", "potatoes", "carrots"];
        const produce = fruits.concat(vegetables);
        console.log(produce);
        // Prints: ["apples", "bananas", "pears", "corn", "potatoes", "carrots"]

        const produce = [fruits, vegetables];
        console.log(produce);
        // Prints: [Array[3], Array[3]]

        // 剩余参数也用三个连续的点表示，能够将不定数量的元素表示为数组
        // 将变量赋数组值时
        const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
        const [total, subtotal, tax, ...items] = order;
        console.log(total, subtotal, tax, items);
        // Prints: 20.17 18.67 1.5 ["cheese", "eggs", "milk", "bread"]
        // 通过使用剩余参数，数组中剩余的值(作为数组)被分配给了items

        // 可变参数函数
        function sum(...nums){
            let total = 0;
            for(const num of nums){
                total += num;
            }
            return total;
        }


        // 箭头函数
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(function(name){
            return name.toUpperCase();
        });

        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
            name => name.toUpperCase()
        );

        // 将函数转换为箭头函数
        // 1、删掉关键字function
        // 2、删掉圆括号
        // 3、删掉左右花括号
        // 4、删掉关键字return
        // 5、删掉分毫
        // 在参数列表和函数主体之间添加一个箭头(=>)

        // 习题1
        setTimerout(() => {
            console.log('starting the test');
            test.start();
        },2000);

        setTimerout(_ => {
            console.log('starting the test');
            test.start();
        },2000);

        const vowels = 'aeiou'.split('');
        const bigVowels = vowels.map((letter) => letter.toUpperCase());

        const vowels = 'aeiou'.split('');
        const bigVowels = vowels.map(letter => letter.toUpperCase());
        // Q:以上哪些项的箭头函数格式正确
        // A:都正确

        // 简写主题语法 (在函数主体周围没有花括号，自动返回表达式)
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map(
            name => name.toUpperCase
        );

        // 常规主体语法 (它将函数主体放在花括号内，需要使用return语句来返回内容)
        const upperizedNames = ['Farrin', 'Kagure', 'Asser'].map( name => {
            name = name.toUpperCase();
            return `${name} has ${name.length} characters in their name`;
        });

        // 习题2
        // 题目
        const colors = ['red', 'blue', 'green', 'yellow', 'orange', 'black'];
        
        // 选项1
        const crazyColors = colors.map(color => {
            const jumble = color.split('').reverse();
            return jumble.join('') + "!";
        });
        // 选项2
        const crazyColors = colors.map(color => {
            color.split('').reverse().join('') + "!";
        });
        // 选项3
        const crazyColors = colors.map(color => color.split('').reverse().join('') + "!");
        // 选项4
        const crazyColors = colors.map(color => color.split('').reverse().join('') + "!");
        // Q:以上哪些时正确的箭头函数格式
        // A:1,4


        // "this"和箭头函数
        // 构造函数
        function IceCream(){
            this.scoops = 0;
        }
        // 为IceCream添加addScoop方法
        IceCream.prototype.addScoop = function(){
            setTimeout(() => {
                this.scoops++;
                console.log('scoop added!');
            },500);
        };
        const dessert = new IceCream();
        dessert.addScoop();

        // 默认函数参数
        function greet(name = 'Student', greeting = 'Welcome'){
            return `${greeting} ${name}!`;
        }

        // 习题1
        function houseDescriptor([houseColor = 'green', shutterColors = [red]]){
            return `I have a ${houseColor} house with ${shutterColors.join(' and ')} shutters`;
        }
        // 选项1
        houseDescriptor('red',['white', 'gray', 'pink']);
        // 选项2
        houseDescriptor(['green',['white', 'gray', 'pink']]);
        // 选项3
        houseDescriptor(['blue','purple']);
        // 选项4
        houseDescriptor(['green']);
        // Q:以上哪些选项可以正常运行
        // A:2,4

        // 默认值和解构对象
        function createSundae({scoops = 1, toppings = ['Hot Fudge']} = {}){
            const scoopText = scoops === 1 ? 'scoop' : 'scoops';
            return `Your sundae has ${scoops} ${scoopText} with ${toppings.join(' and ')} toppings.`;
        }
        createSundae({});
        createSundae({scoops:2});
        createSundae({scoops:2, toppings: ['Sprinkles']});
        createSundae({toppings: ['Cookie Dough']});
        // Returns:
        // Your sundae has 1 scoop with Hot Fudge toppings.
        // Your sundae has 2 scoops with Hot Fudge toppings.
        // Your sundae has 2 scoops with Sprinkles toppings.
        // Your sundae has 1 scoop Cookie Dough toppings.

        // 习题2
        function houseDescriptor({houseColor = 'green', shutterColors = ['red']} = {}){
            return `I have a ${houseColor} house with ${shutterColors.join(' and ')} shutters`;
        }
        // 选项1
        houseDescriptor({houseColor:'red',shutterColors:['white','gray','pink']});
        // 选项2
        houseDescriptor({houseColor:'red'});
        // 选项3
        houseDescriptor();
        // 选项4
        houseDescriptor({shutterColors:['orange','blue']});
        // 选项5
        houseDescriptor({});
        // Q:上面的哪些选项可以正常运行
        // A:全都可以
        

        // ES6中的子类
        class Tree {
            constructor(size = '10', leaves = {spring: 'green', summer: 'green', fall: 'orange', winter: null}){
                this.size = size;
                this.leaves = leaves;
                this.leafColor = null;
            }

            changeSeason(season){
                this.leafColor = this.leaves[season];
                if(season === 'spring'){
                    this.size += 1;
                }
            }
        }

        class Maple extends Tree {
            constructor(syrupQty = 15, size, leaves){
                super(size, leaves);
                this.syrupQty = syrupQty;
            }
            changeSeason(season) {
                super.changeSeason(season);
                if(season === 'spring'){
                    this.syrupQty += 1;
                }
            }
            gatherSyrup(){
                this.syrupQty -= 3;
            }
        }
        const myMaple = new Maple(15,5);
        myMaple.changeSeason('fall');
        myMaple.gatherSyrup();
        myMaple.changeSeason('spring');


        // Symbol
        // 创建Symbol，输入Symbol()，并添加一个可选的字符串作为其描述
        // 避免相同名称的对象被覆盖
        // Symbo.iterator相当于迭代器的接口，只有对象里有这个symbol的属性，才可以认为此对象是可迭代的

        // 使用默认数组的默认迭代器访问数组钟的每个值
        const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const arrayIterator = digits[Symbo.iterator]();

        console.log(arrayIterator.next()); // Object{value: 0, done: false};
        console.log(arrayIterator.next()); // Object{value: 1, done: false};
        console.log(arrayIterator.next()); // Object{value: 2, done: false};


        // 集合(Set)
        // Set与数组之间的区别：
        // 1、Set不基于索引，不能根据集合中的条目在集合中的位置引用这些条目
        // 2、Set中的条目不能单独被访问
        // 基本上，Set是让你可以存储唯一条目的对象。你可以向Set中添加条目，删除条目，并循环访问Set。这些条目可以是原始值或对象。
        const games = new Set(['Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart', 'Super Mario Bros.']);
        console.log(games); // Set {'Super Mario Bros.', 'Banjo-Kazooie', 'Mario Kart'}
        // 在创建Set时，会自动移除重复的条目"Super Mario Bros."

        // 修改Set 使用名称对应的.add()和.delete()方法
        // 使用.size属性可以返回Set中的条目数
        // 使用.has()方法可以检查Set中是否存在某个条目
        // 使用.values()方法可以返回Set中的值，返回值是SetIterator对象


        // Map(映射)
        // 如果说Set类似于数组，那么Map就类似于对象，因为Map存储键值对，和对象包含命名属性及值相类似
        // 本质上，Map是一个可以存储键值对的对象，键和值都可以是对象、原始值或二者的结合

        const employees = new Map();
        console.log(employees);
        // return: Map{}

        // 修改Map
        // 和Set不同，需要使用Map的.set()方法添加键值
        employees.set('james.parkes@udacity.com',{
            firstName: 'James',
            lastName: 'Parkes',
            role: 'Content Developer' 
        });
        employees.set('julia@udacity.com', {
            firstName: 'Julia',
            lastName: 'Van Cleve',
            role: 'Content Developer'
        });
        employees.set('richard@udacity.com', {
            firstName: 'Richard',
            lastName: 'Kalehoff',
            role: 'Content Developer'
        });
        console.log(employees);

        // return：Map {'james.parkes@udacity.com' => Object {...}, 'julia@udacity.com' => Object {...}, 'richard@udacity.com' => Object {...}}
        // .set() 方法有两个参数。第一个参数是键，用来引用第二个参数，即值。

        // 要移除键值对，只需使用 .delete() 方法。
        employees.delete('julia@udacity.com');
        employees.delete('richard@udacity.com');
        console.log(employees);

        // return：Map {'james.parkes@udacity.com' => Object {firstName: 'James', lastName: 'Parkes', role: 'Course Developer'}}

        // 同样，和 Set 类似，你可以使用 .clear() 方法从 Map 中删除所有键值对。
        employees.clear()
        console.log(employees);
        // return：Map {}

        // 处理Map
        // 构建 Map 后，可以使用 .has() 方法并向其传入一个键来检查 Map 中是否存在该键值对。
        const members = new Map();
        members.set('Evelyn', 75.68);
        members.set('Liam', 20.16);
        members.set('Sophia', 0);
        members.set('Marcus', 10.25);
        console.log(members.has('Xavier'));
        console.log(members.has('Marcus'));
        // return: false  true

        // 还可以通过向 .get() 方法传入一个键，检索 Map 中的值。
        console.log(members.get('Evelyn')); // 75.68

        // 循环访问Map
        // 1. 使用 MapIterator
        // 在 Map 上使用 .keys() 和 .values() 方法将返回新的迭代器对象，叫做 MapIterator。你可以将该迭代器对象存储在新的变量中，并使用 .next() 循环访问每个键或值。你所使用的方法将决定迭代器是否能够访问 Map 的键或值。
        let iteratorObjForKeys = members.keys();
        iteratorObjForKeys.next();
        // return：Object {value: 'Evelyn', done: false}
        // 使用 .next() 获得下个键值对。
        iteratorObjForKeys.next();
        // return：Object {value: 'Liam', done: false}
        iteratorObjForKeys.next();
        // return：Object {value: 'Sophia', done: false}

        // 另一方面，使用 .values() 方法访问 Map 的值，然后重复同一流程。
        let iteratorObjForValues = members.values();
        iteratorObjForValues.next();
        // return：Object {value: 75.68, done: false}

        // 2. 使用 for...of 循环
        for (const member of members) {
            console.log(member);
        }
        // return：['Evelyn', 75.68]
        //  ['Liam', 20.16]
        //  ['Sophia', 0]
        //  ['Marcus', 10.25]

        // 3.使用 Map 的 .forEach() 方法循环访问每个键值对
        members.forEach((value, key) => console.log(value, key));
        // return：'Evelyn' 75.68
        //  'Liam' 20.16
        //  'Sophia' 0
        //  'Marcus' 10.25


        // WeakMap
        // WeakMap 和普通 Map 很像，但是具有以下关键区别：
        // 1.WeakMap 只能包含对象作为键，
        // 2.WeakMap 无法迭代，意味着无法循环访问，并且
        // 3.WeakMap 没有 .clear() 方法。
        const book1 = { title: 'Pride and Prejudice', author: 'Jane Austen' };
        const book2 = { title: 'The Catcher in the Rye', author: 'J.D. Salinger' };
        const book3 = { title: `Gulliver's Travels`, author: 'Jonathan Swift' };

        const library = new WeakMap();
        library.set(book1, true);
        library.set(book2, false);
        library.set(book3, true);

        console.log(library);
        // return：WeakMap {Object {title: 'Pride and Prejudice', author: 'Jane Austen'} => true, Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false, Object {title: 'Gulliver's Travels', author: 'Jonathan Swift'} => true}

        // 如果添加对象以外的内容作为键
        library.set('The Grapes of Wrath', false);
        // 系统将报错
        // return：Uncaught TypeError: Invalid value used as weak map key(…)

        // 垃圾回收
        // 在 JavaScript 中，创建新的值时会分配内存，并且当这些值不再需要时，将自动释放内存。这种内存不再需要后释放内存的过程称为垃圾回收。
        // WeakMap 通过专门处理对象作为键来利用这一点。如果将对象设为 null，则本质上是删除该对象。当 JavaScript 的垃圾回收器运行时，该对象之前占用的内存将被释放，以便稍后在程序中使用。
        book1 = null;
        console.log(library);
        // return：WeakMap {Object {title: 'The Catcher in the Rye', author: 'J.D. Salinger'} => false, Object {title: 'Gulliver’s Travels', author: 'Jonathan Swift'} => true}


        // Promise
        new Promise(function (resolve, reject) {
            window.setTimeout(function createSundae(flavor = 'chocolate') {
                const sundae = {};
                // 请求冰淇淋
                // 得到锥形蛋筒
                // 加热冰淇淋
                // 舀一大勺到蛋筒里!
                resolve(sundae);
            }, Math.random() * 2000);
        });
        // 当 sundae 被成功创建后，它会调用 resolve 方法并向其传递我们要返回的数据，返回的数据是完成的 sundae。因此 resolve 方法用来表示请求已完成，并且成功完成了请求。

        new Promise(function (resolve, reject) {
            window.setTimeout(function createSundae(flavor = 'chocolate') {
                const sundae = {};
                // 请求冰淇淋
                // 得到锥形蛋筒
                // 加热冰淇淋
                // 舀一大勺到蛋筒里!
                if ( iceCreamConeIsEmpty(flavor)  ) {
                    reject(`Sorry, we're out of that flavor :-(`);
                }
                resolve(sundae);
            }, Math.random() * 2000);
        });
        // 如果请求无法完成，则使用 reject 方法。注意，即使请求失败了，我们依然可以返回数据，我们只是返回了一段文字，表示没有我们想要的冰激凌口味。

        // 首先要注意的是，Promise 将立即返回一个对象。
        const myPromiseObj = new Promise(function (resolve, reject) {
            // 圣代创建代码
        });
        // 该对象上具有一个 .then() 方法，我们可以让该方法通知我们 promise 中的请求成功与否。.then() 方法会接收两个函数：
        // 1.请求成功完成时要运行的函数
        // 2.请求失败时要运行的函数
        mySundae.then(function(sundae) {
            console.log(`Time to eat my delicious ${sundae}`);
        }, function(msg) {
            console.log(msg);
            self.goCry(); // 不是一个真正的方法
        });
        // 传递给 .then() 的第一个函数将被调用，并传入 Promise 的 resolve 函数需要使用的数据。这里，该函数将接收 sundae 对象。第二个函数传入的数据会在 Promise 的 reject 函数被调用时使用。


        // Proxy
        // 要创建 Proxy（代理）对象，使用 Proxy 构造函数 new Proxy();。Proxy 构造函数接收两个项目：
        // 1.它将要代理的对象
        // 2.包含将为被代理对象处理的方法列表的对象
        // 第二个对象叫做处理器

        var richard = {status: 'looking for work'};
        var agent = new Proxy(richard, {});
        agent.status; // return： 'looking for work'

        // Get Trap（捕获器）
        const richard = {status: 'looking for work'};
        const handler = {
            get(target, propName) {
                console.log(target); // `richard` 对象，不是 `handler` 也不是`agent`
                console.log(propName); // 代理(本例中为`agent`)正在检查的属性名称
            }
        };
        const agent = new Proxy(richard, handler);
        agent.status; // 注销 richard 对象

        // 直接获取 Proxy 的返回信息
        const richard = {status: 'looking for work'};
        const handler = {
            get(target, propName) {
                return `He's following many leads, so you should offer a contract as soon as possible!`;
            }
        };
        const agent = new Proxy(richard, handler);
        agent.status; // 返回文本 `He's following many leads, so you should offer a contract as soon as possible!`


        // set trap 用来截获将更改属性的代码。set trap 将接收： 它代理的对象 被设置的属性 Proxy 的新值
        const richard = {status: 'looking for work'};
        const handler = {
            set(target, propName, value) {
                if (propName === 'payRate') { // 如果工资正在确定，则需要15%作为佣金。
                    value = value * 0.85;
                }
                target[propName] = value;
            }
        };
        const agent = new Proxy(richard, handler);
        agent.payRate = 1000; // 将演员的工资设置为 1,000美元
        agent.payRate; // 850美元是演员的实际工资

        // get trap - 使 proxy 能处理对属性访问权的调用
        // set trap - 使 proxy 能将属性设为新值
        // apply trap - 使 proxy 能被调用（被代理的对象是函数）
        // has trap - 使 proxy 能使用 in 运算符
        // deleteProperty trap - 使 proxy 能确定属性是否被删除
        // ownKeys trap - 使 proxy 能处理当所有键被请求时的情况
        // construct trap - 使 proxy 能处理 proxy 与 new 关键字一起使用当做构造函数的情形
        // defineProperty trap - 使 proxy 能处理当 defineProperty 被用于创建新的对象属性的情形
        // getOwnPropertyDescriptor trap - 使 proxy 能获得属性的描述符
        // preventExtenions trap - 使 proxy 能对 proxy 对象调用 Object.preventExtensions()
        // isExtensible trap - 使 proxy 能对 proxy 对象调用 Object.isExtensible
        // getPrototypeOf trap - 使 proxy 能对 proxy 对象调用 Object.getPrototypeOf
        // setPrototypeOf trap - 使 proxy 能对 proxy 对象调用 Object.setPrototypeOf

        // 生成器和迭代器
        // 生成器被调用时，它不会运行函数中的任何代码，而是创建和返回迭代器。该迭代器可以用来运行实际生成器的内部代码。
        const generatorIterator = getEmployee();
        generatorIterator.next();
        // 迭代器的 .next() 方法第一次被调用时，它会运行生成器中的所有代码。代码始终没有暂停
        // 关键字 yield 是 ES6 中新出现的关键字。只能用在生成器函数中。yield 会导致生成器暂停下来。向生成器中添加 yield
        function* getEmployee() {
            console.log('the function has started');

            const names = ['Amanda', 'Diego', 'Farrin', 'James', 'Kagure', 'Kavita', 'Orit', 'Richard'];

            for (const name of names) {
                console.log(name);
                yield;
            }

            console.log('the function has ended');
        }
        // 现在 for...of 循环中出现了 yield。如果我们调用该生成器（生成迭代器），然后调用 .next()，将获得以下输出：
        const generatorIterator = getEmployee();
        generatorIterator.next();
        // return：the function has started
        // Amanda
        // 暂停
        generatorIterator.next();
        // return：Diego
        // 它能完全记住上次停下的地方，它获取到数组中的下一项（Diego），记录它，然后再次触发了 yield，再次暂停。

        // console.log(name)切换成 yield name。更改后，当生成器运行时，它会把姓名从函数里返回出去，然后暂停执行代码



    </script>
</body>
</html>