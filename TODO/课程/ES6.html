<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 习题1.1
        function getClothing(isCold){
            if(isCold){
                var freezing = "Grab a jacket!";
            }else{
                var hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：undefined
        // 提升：提升是浏览器解析JavaScript的结果。本质上，在执行任何JavaScript代码之前，所有的变量都会被"提升"，也就是提升到函数作用域的顶部。因此在运行时，getClothing()函数实际上看起来如下
        function getClothing(isCold){
            var freezing, hot;
            if(isCold){
                freezing = "Grab a jacket!";
            }else{
                hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // let和const
        // 使用let和const声明的变量解决了这种提升问题，因为它们的作用域是到块，而不是函数。
        // 如果在代码块中使用let或const声明变量，那么该变量会陷入暂时性死区，直到该变量的声明被处理。这种行为会阻止变量被访问，除非它们被声明了。
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // 使用let和const声明的变量仅在它们所声明的块中可用

        // 习题1.2
        function getClothing(isCold){
            if(isCold){
                let freezing = "Grab a jacket!";
            }else{
                let hot = "It's a shorts kind of day.";
                console.log(freezing);
            }
        }
        // Q：运行getClothing(false)后的输出是什么
        // A：ReferenceError:freezing is not defined
        // 使用let声明的变量可以重新赋值，但是不能在同一作用域内重新声明
        // 使用const声明的变量必须赋初始值，但是不能在同一作用域内重新声明，也无法重新赋值

        // 习题1.3
        let instructor = 'James';
        instructor = 'Richard';
        console.log(instructor);
        // Q:运行以上代码后的输出是什么
        // A:Richard

        // 模板字面量
        // 源代码
        var note = teacher.name + ',\n\n' +
        'Please excuse ' + student.name + '.\n' +
        'He is recovering from the flu.\n\n' +
        'Thank you,\n' +
        student.guardian;
        // 更改
        var note = `${teacher.name},
        Please excuse ${student.name}.
        He is recovering from the flu.
        Thankyou,
        ${student.guardian}`;

        // 解构数组中的值
        const point = [10, 25, 34];

        const [x, y, z] = point;

        console.log(x, y, z);
        // Prints:10 25 -34
        
        // 习题2.1
        let positions = ['Gabrielle', 'Jarrod', 'Kate', 'Fernando', 'Mike', 'Walter'];
        let [first, second, third] = positions;
        // Q:运行以上代码后，second的值为多少
        // A:Jarrod

        // 习题2.2
        const circle = {
            radius: 10,
            color: 'orange',
            getArea: function(){
                return Math.PI * this.radius * this.radius;
            },
            getCircumference: function(){
                return 2*Math.PI * this.radius;
            }
        };
        let {radius, getArea, getCircumference} = circle;
        // Q:调用getArea()后会返回什么
        // A:NaN
        // 在解构该对象并将getArea()方法存储到getArea变量中时，它无法再访问circle对象中的this
    </script>
</body>
</html>